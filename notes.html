<!DOCTYPE html>
<html>
<head>
<title>learnings.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h2 id="auto">auto</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">auto</span> i = <span class="hljs-number">10</span>, &amp;r = i;    <span class="hljs-comment">// r is an int reference</span>
<span class="hljs-keyword">auto</span> x = r;     <span class="hljs-comment">// inferred type of x is int, not int&amp;</span>
<span class="hljs-keyword">auto</span> &amp;y = i;    <span class="hljs-comment">// now y is a reference to i</span>
</div></code></pre>
<p>auto ignores top level const-ness while deducing type. However, low level const-ness is preserved.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-comment">// top level const</span>
<span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> p = &amp;i;  <span class="hljs-comment">// lower level const</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">1</span>, &amp;cr = ci;
<span class="hljs-comment">// int&amp; r = ci; // ERROR: cannot bind int&amp; to const int</span>
<span class="hljs-keyword">auto</span> b = ci;    <span class="hljs-comment">// top level const is dropped</span>
b = <span class="hljs-number">10</span>;
<span class="hljs-keyword">auto</span> c = cr;    <span class="hljs-comment">// cr is alias for ci, which has top level const</span>
c = <span class="hljs-number">20</span>;
<span class="hljs-keyword">auto</span> d = &amp;ci;   <span class="hljs-comment">// d is deduced to be of type const int*</span>
<span class="hljs-comment">// *d = 30;     // ERROR: cannot modify d</span>
</div></code></pre>
<p>If deduced type should be a top-level const add const to auto in declaration</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> x = i;
</div></code></pre>
<p>Another mind bender</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
<span class="hljs-keyword">auto</span> &amp;cr = i, *cp = &amp;i;
<span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;
<span class="hljs-keyword">auto</span> &amp;b = a, *p = i;    <span class="hljs-comment">// ERROR (4)</span>
<span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<p>Line 4 is an error, as auto will be normal int according to type deduced for b, and const int for p.
So, effectively, we are asking auto to work as both int and const int in same statement. Hence it is an error.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;j = i;
j = <span class="hljs-number">20</span>;     <span class="hljs-comment">// ERROR: can't change i using j</span>
</div></code></pre>
<h2 id="decltype">decltype</h2>
<p>sum has whatever type <code>f()</code> returns. Note that <code>f()</code> is not called.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">decltype</span>(f()) sum = x;
</div></code></pre>
<p>decltype handles top level const-ness and references differently from auto. If applied to a vairiable, it preserves top-level const-ness and whether the variable is a reference.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>, &amp;r = i;
<span class="hljs-keyword">decltype</span>(r) s;  <span class="hljs-comment">// ERROR: as int reference should be initialized;</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
<span class="hljs-keyword">decltype</span>(j) p;  <span class="hljs-comment">// ERROR: as const int needs to be initialized</span>
</div></code></pre>
<p><code>decltype</code> is the <em>only</em> context where a reference is treated differently from the object to which it refers.</p>
<p>There is difference between application of <code>decltype</code> to variable vs expression. <code>decltype</code> when applied to an expression yields a reference, when the expression is an lvalue.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">decltype</span>(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>) x = <span class="hljs-number">10</span>;   <span class="hljs-comment">// x is of type int</span>
<span class="hljs-keyword">int</span> *p = &amp;x;
<span class="hljs-keyword">int</span> q = <span class="hljs-number">10</span>;
<span class="hljs-keyword">decltype</span>(*p) r = q;     <span class="hljs-comment">// r is now int&amp;, as *p is an expression and lvalue</span>
<span class="hljs-built_in">cout</span> &lt;&lt; ++q &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 11 11</span>
</div></code></pre>
<p>When we apply <code>decltype</code> to any variable, we get the type of that variable. However if we apply parenthesis to the variable, it is treated as an expression. Since the expression is now an lvalue, we get a reference type.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">decltype</span>(i) j;  <span class="hljs-comment">// OK, j is of type int</span>
<span class="hljs-keyword">decltype</span>((i)) k;    <span class="hljs-comment">// ERROR: k is of type int&amp;</span>
</div></code></pre>
<p>In general, the form <code>decltype ((variable))</code> always yields a reference of type of variable, however <code>decltype(variable)</code> may or may not be a reference type depending on type of variable.</p>
<h2 id="string">string</h2>
<p>Different string constructors/initializers</p>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> s1;
<span class="hljs-built_in">string</span> s2 = s1;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;
<span class="hljs-built_in">string</span> s4 = <span class="hljs-string">"Hello"</span>;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s5</span><span class="hljs-params">(<span class="hljs-string">"Hello"</span>)</span></span>;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s6</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>;
</div></code></pre>
<p><code>getline</code> function reads from stream uptil and including it finds a newline character, and stores it in the string, without newline character.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> line; 
<span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>, line)) {
    <span class="hljs-built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p>Some interesting behavior with string concatentation</p>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"abc"</span>;
<span class="hljs-built_in">string</span> s2 = s1 + <span class="hljs-string">"def"</span> + <span class="hljs-string">"ghi"</span> + <span class="hljs-string">'l'</span>; <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">string</span> s3 = <span class="hljs-string">"abc"</span> + <span class="hljs-string">"def"</span> + s1; <span class="hljs-comment">// ERROR</span>
</div></code></pre>
<p>Initialization of s3 is invalid as one of the operands to '+' has to be a string. This is not a problem for s2, as <code>s1 + &quot;def&quot;</code> yield a temporary string object which can be valid left operand to + operator.</p>
<p>Be careful while mixing signed and unsigned types in comparison expressions. This prints false (0) as i is converted to unsigned which wraps up to a very large number.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> i = <span class="hljs-number">-10</span>;
<span class="hljs-built_in">string</span>::size_type j = <span class="hljs-number">20</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; (j &gt; i) &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h2 id="arrays">Arrays</h2>
<p>Array initialization in 1 dimension</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a1[<span class="hljs-number">10</span>];  <span class="hljs-comment">// possibly contains random values</span>
<span class="hljs-keyword">int</span> a2[<span class="hljs-number">10</span>] = {};    <span class="hljs-comment">// All values are 0</span>
<span class="hljs-keyword">int</span> a3[<span class="hljs-number">10</span>] = {<span class="hljs-number">0</span>};   <span class="hljs-comment">// All values are 0</span>
<span class="hljs-keyword">int</span> a4[<span class="hljs-number">10</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}; <span class="hljs-comment">// All values after first 2 are 0</span>
<span class="hljs-comment">// values starting from index 3 are 3, 4 and 5.</span>
<span class="hljs-comment">// Rest all are 0.</span>
<span class="hljs-keyword">int</span> a5[<span class="hljs-number">10</span>] = {[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
</div></code></pre>
<p>Array initialization in multiple dimensions</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> b1[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];   <span class="hljs-comment">// random values</span>
<span class="hljs-comment">// b2[0][0] is 1, rest all are 0</span>
<span class="hljs-keyword">int</span> b2[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = {<span class="hljs-number">1</span>};
<span class="hljs-comment">// b[0][0] = 1, b[1][0] = 2, rest all are 0</span>
<span class="hljs-keyword">int</span> b3[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = {{<span class="hljs-number">1</span>}, {<span class="hljs-number">2</span>}};
<span class="hljs-comment">// b[0][0] = 1, b[1][0] = 2, b[1][1] = 3, rest all are 0</span>
<span class="hljs-keyword">int</span> b4[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = {{<span class="hljs-number">1</span>},<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
</div></code></pre>
<p>Using range based for loop with multidimensional arrays</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> b[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>};
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> row : b) {         <span class="hljs-comment">// (1) ERROR</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> col : row) {   
        <span class="hljs-built_in">cout</span> &lt;&lt; col &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p>The above code does not compile. (1) tries to copy 1D array to row, which ends up copying the int* pointer. int* pointer is not iterable using begin() method. Hence, this is an error. The fix is simple. Change (1) to <code>const auto&amp; row : b</code>
Multidimension array and pointers</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> b[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>};
<span class="hljs-keyword">int</span> (*p2)[<span class="hljs-number">4</span>] = &amp;b[<span class="hljs-number">1</span>];       <span class="hljs-comment">// (1)</span>
<span class="hljs-built_in">cout</span> &lt;&lt; p2[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 10</span>
</div></code></pre>
<p>The declaration in line (1) reads as:<br>
p2 is a <em>pointer to an array</em> of 4 ints (inside out starting from variable name) starting from 5.
Thus, <code>p2[1]</code> is equal to the array <code>{9,10,11,12}</code>.<br>
This is differenr from below</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>* p3[<span class="hljs-number">4</span>];
p3 = &amp;b[<span class="hljs-number">1</span>];     <span class="hljs-comment">// ERROR</span>
p3[<span class="hljs-number">0</span>] = b[<span class="hljs-number">1</span>];   <span class="hljs-comment">// OK</span>
</div></code></pre>
<p>Here, <em>p3 is an array</em> of size 4.</p>
<blockquote>
<p>Prefix iterator increment operator yields lvalue, while postfix version yields rvalue.</p>
</blockquote>
<p><code>const_cast</code> can be used to change a const to non const type. However, if the object was originally const, the result of writing to it after casting away constness is undefined.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str = <span class="hljs-string">"Kaustubh"</span>;
<span class="hljs-keyword">char</span>* p = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(str);   <span class="hljs-comment">// no error</span>
p[<span class="hljs-number">1</span>] = <span class="hljs-string">'0'</span>;     <span class="hljs-comment">// undefined behavior, gives bus error on my mac</span>
</div></code></pre>
<h2 id="function-matching---overload-resolution">Function matching - Overload resolution</h2>
<p>This is used to decide which function to call when calling an overloaded function.<br>
Candidate functions - Those functions which have same name and are visible.<br>
Viable functions - Those candidate functions where number of arguments match, and types of argument and parameters are exact match or argument is convertible to parameter type.<br>
If the number of viable functions are more than 1, then following rules apply.  Lets say there are 2 viable functions A and B. A will be selected if</p>
<ol>
<li>At least one argument is better match for A as compared to B.</li>
<li>There is no argument of B which is a better match than A.
If these conditions are not met, the function call is ambiguous, and a compiler error will be thrown.
Better match is the one which doesn't require type conversion. Here type conversion includes both narrowing and widening conversions.
Examples</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{      <span class="hljs-comment">// (1)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside f(int a, int b)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">double</span> b)</span> </span>{   <span class="hljs-comment">// (2)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside f(int a, double b)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span> </span>{    <span class="hljs-comment">//(3)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside f(double a, double b)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);     <span class="hljs-comment">// (1)</span>
f(<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>); <span class="hljs-comment">// (3)</span>
f(<span class="hljs-number">1</span>,<span class="hljs-number">2.0</span>);   <span class="hljs-comment">// (2)</span>
f(<span class="hljs-number">1.0</span>,<span class="hljs-number">2</span>);   <span class="hljs-comment">// ERROR: ambiguous    </span>
}
</div></code></pre>
<p>There are further rules to determine which conversions rank above another, but having your code rely on those arcane rules is not a great practice.</p>
<h2 id="function-pointers">Function pointers</h2>
<p>Multiple ways to declare function pointer types</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;    <span class="hljs-comment">// assume this function type</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">using</span> ftype1 = <span class="hljs-keyword">double</span> (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);           <span class="hljs-comment">// (1)</span>
    <span class="hljs-keyword">using</span> ftype2 = <span class="hljs-keyword">auto</span> (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) -&gt; <span class="hljs-keyword">double</span>;   <span class="hljs-comment">// (2)</span>
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> <span class="hljs-title">ftype3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;            <span class="hljs-comment">// (3)</span>
    ftype1* pf = f;
}
</div></code></pre>
<p>All the types defined in (1), (2) and (3) are equivalent.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(f)</span> ftype4</span>;
</div></code></pre>
<p>This also works, but not in case the function f is overloaded.</p>
<p>In (1), copy constructor of A is called, not assignemt operator.<br>
In (2), assigment operator is used.</p>
<pre class="hljs"><code><div>A B::getA() {       <span class="hljs-comment">// v1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;a;
}
A&amp; B::getA() {      <span class="hljs-comment">// v2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;a;
}
A obj1 = objB.getA();   <span class="hljs-comment">// (1)</span>
A obj2;
obj2 = objB.getA();     <span class="hljs-comment">// (2)</span>

<span class="hljs-keyword">const</span> A&amp; obj3 = objB.getA();   <span class="hljs-comment">// (3)</span>
A&amp; obj4 = objB.getA();         <span class="hljs-comment">// (4)</span>
</div></code></pre>
<p>In case getA() is defined like v1, copy constructor will always be called when returning the object. Copy ctor is called once for (3). However, if call is made like (1), copy ctor is still called only once as the returned temporary is assigned to obj1.<br>
In case of (3), it is error to omit const, as plain non const reference cannot refer to a temporary returned by v1 of getA() method.
(4) is valid only with v2. In this case copy ctor is not called.<br>
If (2) is used with v1, copy constructor is called to create a temporary object to return by value. Assignment operator is also called.</p>
<p>A friend declaration only specifies access, that is, this function can access private variables. It is <em>NOT</em> a substitute for declaration, which is required by any users outside the class. It may appear to work in some cases due to ADL (Argument dependent lookup, later on this), however it will not work always like a real declaration.</p>
<p>Within a class declaration, members which define a type must appear before they are used. This has something to do with name lookup (later). This restriction is not applicable to data or function members. For example,</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> pos = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type;
<span class="hljs-keyword">private</span>:
    pos cursor_;
}
</div></code></pre>
<p>If you make a function inline, its definition needs to be visible to compiler. That is, the function must be defined in header class itself.</p>
<p>A <code>const</code> member function that returns <code>*this</code> should have a return type that is a const reference.</p>
<p>It is possible to overload a function based on its <em>const</em>-ness. A const function will only match to a const calling object. However, a non const function can call both a const version as well as a non const version, but non const version is a better match.</p>
<h2 id="forward-declaration">Forward Declaration</h2>
<p>A class can be declared with just the class name, without the body.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Screen</span>;</span>
</div></code></pre>
<p>This allows the typename <code>Screen</code> to be used in limited ways before the whole class declaration is available. We cannot make an object of Screen before the class is completely defined, but we can declare pointers or references.<br>
For the same reason, a class cannot contain an object of its type, but can contain its reference or pointer.</p>
<p>A friend declaration inside a class is allowed to be defined as well at same place.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{ ... }
    X() { f(); }    <span class="hljs-comment">// ERROR</span>
}
</div></code></pre>
<p>However, any use of f() is not allowed until the declaration of f() is seen outside the class as well.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{ ... }
    X() { f(); }    <span class="hljs-comment">// OK</span>
}
</div></code></pre>
<p>Similarly, just declaring f() after the class is not enough. Declaration needs to be seen before its use.</p>
<p>When a member function is defined outside of a class, we need to use class name with scope resolution operator to indicate that the function belongs to the scope of specified class. Anything in function defintion that occurs after the name of class is automatically considered to belong to class scope.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::size_type index;
    <span class="hljs-function">index <span class="hljs-title">fun</span><span class="hljs-params">(index aa)</span></span>;
}
A::index A::fun(index aa) { ... }
</div></code></pre>
<p>In the above code, the parameter aa's type is not required to be qualified with A::, but the return type has to be qualified, as it occurs before the function name (which contains A:<img class="emoji" alt="smiley" src="data:image/png;base64,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" />.</p>
<p>For name resolution, class definitions are processed in 2 phases.</p>
<ol>
<li>All the member declarations are compiled first.</li>
<li>Function bodies are compiled only after the entire class has been seen.</li>
</ol>
<p>Thus, when defining inline functions, we can use data members in the body even if they are declared later in the class, as member definitions are not yet processed.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> j;
    <span class="hljs-keyword">int</span> i;
    
    <span class="hljs-comment">// WARN: field i is uninitialized when used here.</span>
    X(<span class="hljs-keyword">int</span> a) : i(<span class="hljs-number">10</span>), j(i * <span class="hljs-number">10</span>) {}
};
</div></code></pre>
<p>The order of member initialization in constructor initializer list is always same as the order in which members are declared in class, NOT the one in which the appear in member initializer list. The above code compiles but initializes j with garbage value of i. <em>ALWAYS</em> define the members in initializer list in same order as declared in the class definition.<br>
Another useful practice is to use constructor parameters only for initialization of members.</p>
<h2 id="implicit-conversion">Implicit conversion</h2>
<p>Implicit conversions are allowed for user defined types using single argument constructors. Only 1 level of implicit conversion is allowed.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> str;
<span class="hljs-function"><span class="hljs-keyword">public</span>
    <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(X xobj)</span></span>;
</div></code></pre>
<p>The above can be called as follows</p>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> s = <span class="hljs-string">"some string"</span>;
fun(s);         <span class="hljs-comment">// (1) allowed, implicit conversion</span>
fun(<span class="hljs-string">"abc"</span>);     <span class="hljs-comment">// (2) not allowed</span>
</div></code></pre>
<p>(2) is not allowed, as it requires 2 conversions, <code>char*</code> to <code>string</code> and <code>string</code> to <code>X</code>.</p>
<p>We can also prevent these implicit conversions by marking the constructor as <code>explicit</code>.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span></span>;
</div></code></pre>
<h2 id="aggregate-class">Aggregate Class</h2>
<p>It is a class whose object can be instantiated directly using a brace initialization syntax, much like plain a struct.</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-built_in">string</span> b;
};
<span class="hljs-comment">// Intialization</span>
X xobj = {<span class="hljs-number">10</span>, <span class="hljs-string">"abc"</span>}
</div></code></pre>
<p>A class is an aggregate class if</p>
<ol>
<li>It has only public members.</li>
<li>No user specified constructors.</li>
<li>No base class.</li>
<li>No in class initializers.</li>
<li>No virtual functions.</li>
</ol>
<p>Generally not a good idea to use it. If a member is added ever to the class, all the invocations will need to be updated.</p>
<h2 id="literal-class">Literal class</h2>
<p>Literal classes are the ones where their objects can be created at compile time, and assigned to constexpr variables.<br>
This means, that the at least one constructor for a literal class have to be constexpr<br>
A constexpr constructor must initialize all the class members. For this to work, all data members must also be of literal type.<br>
The class must not define a custome destructor.</p>
<p>Declaring a member method as <code>constexpr</code> does not implicitly make it a <code>const</code> method as well. This used to be the case in C++11, but was fixed later in C++17.</p>
<h2 id="static-keyword">static keyword</h2>
<p>Static data members must not be initialized inside the class. A definition should alwyays be provided outside the class</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> str1 = <span class="hljs-string">"abc"</span>;         <span class="hljs-comment">// ERROR</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> str2 = <span class="hljs-string">"abc"</span>;   <span class="hljs-comment">// ERROR</span>
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> str3;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> str4;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;           <span class="hljs-comment">// OK</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">10</span>;                 <span class="hljs-comment">// ERROR</span>

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i3;            <span class="hljs-comment">// ERROR</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i4 = <span class="hljs-number">10</span>;       <span class="hljs-comment">// OK</span>
};
<span class="hljs-comment">// in .cpp file</span>
<span class="hljs-built_in">string</span> X::str3 = <span class="hljs-string">"abc"</span>; 
<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> X::str4 = <span class="hljs-string">"def"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> X::i1;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> X::i4;
</div></code></pre>
<p>However, we <em>are allowed</em> to provide in-class initializer for static members of const integral type, example i1.<br>
It is strongly suggested to also define even the static const integral types outside the class, as simplest cases like taking the address of i1 will cause compilation to fail.</p>
<p><code>constexpr</code> data members have to be declared as static, and be provided with an in class initializer. We still should define the member ouside class.</p>
<p>static members can exist as incomplete types. This means, that the static member does not have to be fully defined at the point of its declaration.<br>
=&gt; static members can be of the same type as their class</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span>
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">static</span> X obj1;
    X* obj2;
    X obj3;         <span class="hljs-comment">// ERROR</span>
};
</div></code></pre>
<p>A static member can even be default argument for a class method. In above class, it is valid to declare a method such as</p>
<pre class="hljs"><code><div>    ...
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(X = obj)</span></span>;
</div></code></pre>
<p>This is not possible for non static members, as there is no implicit object from which the value can be taken.</p>
<h2 id="io-classes">IO classes</h2>
<p>IO classes (istream, ostream and their hierarchy) do not allow to copy or assign the objects from one to another (deleted copy and assign operators).<br>
Hence, no method can take an i/ostream parameter, or return an i/ostream object. The common way is to pass or return these as ordinary references. Passing a const reference is generally not useful, as any meaningful opreation including read or write, requires changing the internal state of i/ostream object.</p>
<h3 id="using-iostreamiostate">using iostream::iostate</h3>
<p>i/ostream objects can have an internal state called <code>iostate</code> which indicates if the stream is good for read/write operations. It can have following states</p>
<ol>
<li>good - all flags are clear. Equivalent to 0.</li>
<li>bad - generally indicates some serious unrecoverable error, like hardware/driver failure.</li>
<li>fail - set when invalid input in encountered, like reading a string when an int is expected.</li>
<li>eof - when end of file is encountered. fail bit is also set when eof is found.</li>
</ol>
<p><code>cin.fail()</code> method tests for both bad bit and fail bit. Hence, it is a good test to see if the stream is in correct state for processing input.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; i) {
    <span class="hljs-comment">// ...</span>
}
<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">cin</span>.fail()) {
    <span class="hljs-comment">// equivalent</span>
}
</div></code></pre>
<p>Internally this is implemented by <code>cin &gt;&gt; i</code> returning <code>cin</code>, as having i/ostream object overload <code>bool()</code> operator.</p>
<p>There's a special class of type conversion operators which allows us to do that with user defined types (note the lack of return type).</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> </span>{ 
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>;
}
</div></code></pre>
<p>This overloaded conversion operator defines a conversion from the enclosing type to bool.</p>
<p>Getting back to i/ostream, we can manualy change the state of a stream using</p>
<ol>
<li><code>cin.setstate(iostream::ios_base::badbit)</code> adds bad_bit to current state.</li>
<li><code>cin.clear()</code> clears the current state and sets it to good.</li>
<li><code>cin.clear(iostream::ios_state::eofbit)</code> clears the current state and sets it to <code>eofbit</code>.</li>
</ol>
<p>How to clear a single flag, i.e. just remove the bad state?</p>
<pre class="hljs"><code><div><span class="hljs-built_in">cin</span>.clear(<span class="hljs-built_in">cin</span>.rdstate() &amp; ~<span class="hljs-built_in">cin</span>.badbit)
</div></code></pre>
<h3 id="stream-flushing">stream flushing</h3>
<p>By default, <code>ostream</code> is buffered, which means that output may be written at a later time. When is the stream flushed?</p>
<ol>
<li>When <code>endl</code> or <code>ends</code> are used on stream.</li>
<li>When <code>cout.flush()</code> is explicitly called.</li>
<li>If stream manipulator <code>unitbuf</code> is used. It causes stream to flush after each write. This behavior can be turned off again using <code>nounitbuf</code></li>
<li>Reading from/writing to a tied stream.</li>
</ol>
<p>The last point requires more detail. An i/ostream can be tied to at max one ostream. Multiple i/ostreams can tie themselves to same ostream. If, on the stream which ties itself (s1) to ostream (s2), any read/write oepration occurs, s2 will authomatically be flushed.</p>
<p>For example, cin and cerr are tied to cout. Whenever we read something from cin, or write something to cerr, cout is guaranteed to be flushed.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">cin</span>.tie(&amp;<span class="hljs-built_in">cout</span>);     <span class="hljs-comment">// for illustration</span>
ostream* current_tie = <span class="hljs-built_in">cin</span>.tie();
ostream* current_tie = <span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">nullptr</span>);    <span class="hljs-comment">// break the existing tie and return it.</span>
</div></code></pre>
<p>Some bullet points for file operations</p>
<ol>
<li>Cannot open an opened file - puts the ostream in bad mode.</li>
<li>Can open a file either via constructor, or via an open call later.</li>
<li>File does not need to be closed explicitly. Uses RAII idiom.</li>
<li>We can close a file, and use same i/ostream object to open another file later.</li>
</ol>
<h3 id="file-open-modes">File open modes</h3>
<ol>
<li>You can find the file open flags in following classes/type aliases
<ul>
<li>ios_base</li>
<li>ios</li>
<li>ofstream</li>
<li>ifstream</li>
</ul>
</li>
<li><code>in</code> mode is default for file opened by ifstream. <code>out | trunc</code> is default for ofstream.</li>
<li><code>in | out</code> opens the file and seeks to begin. Any write will overwrite bytes from beginning.</li>
<li><code>out</code> or <code>out|trunc</code> or <code>trunc</code> clobbers the file (deletes all contents)</li>
<li><code>app</code> or <code>out|app</code> seeks to end before writes (appends)</li>
<li><code>app|trunc</code> is invalid, results in file open error.</li>
</ol>
<p>stringstream is a lot like iostream. It offers 2 additional methods to instantiate itself from string (for reading as istringstream) or return the underlying string (<code>osstream.str()</code>)</p>
<h2 id="sequential-containers">Sequential Containers</h2>
<p>Containers can hold <em>almost</em> all types (example of exception - references). However, some operations that can be performed on elements of containers specify their own constraints on the element types.<br>
Example - Creating a vector using ctor which takes size is valid only for those element types which have a default ctor.</p>
<p>Iterator operations like <code>iter + n</code> are only supported for containers which provide random access, like <code>vector</code>, <code>deque</code> etc. Not supported for <code>list</code> etc.</p>
<p>sequential contianers define following type aliases</p>
<ol>
<li>value_type</li>
<li>reference</li>
<li>const_reference</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::value_type s1 = <span class="hljs-string">"abc"</span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::reference s2 = <span class="hljs-string">"def"</span>;   <span class="hljs-comment">// ERROR, non const lvalue reference cannot bind to unrelated type.</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::const_reference s3 = <span class="hljs-string">"ghi"</span>;    <span class="hljs-comment">// OK</span>
</div></code></pre>
<p>To get an iterator for a container, use functions like following</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; svec = {<span class="hljs-comment">/*...*/</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator it1 = svec.begin();
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::const_iterator it2 = svec.begin();  <span class="hljs-comment">// OK, will call overloaded version of begin() with const</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator it3 = svec.cbegin();   <span class="hljs-comment">// ERROR</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::const_iterator it4 = svec.cbegin(); <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;::const_iterator it5 = it1;   <span class="hljs-comment">// OK, vice versa is not.</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; csvec = {<span class="hljs-comment">/*...*/</span>};
<span class="hljs-keyword">auto</span> it6 = csvec.begin();   <span class="hljs-comment">// it6 is const_iterator</span>
<span class="hljs-keyword">auto</span> it7 = svec.cbegin();   <span class="hljs-comment">// it7 is const_iterator</span>
</div></code></pre>
<p>When using copy constructor for containers, both container type and element type must match. However, if you use iterator ranger version of ctor, container types do not have to match, however, elements must be convertible from source to destination type implicitly at least.</p>
<h3 id="array">array</h3>
<p><code>array</code> container has its size as a part of its type. So, array of size 10 is a different type from array of size 2.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 3&gt; arr1 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 3&gt; arr2 = {<span class="hljs-number">1</span>};   <span class="hljs-comment">// OK, other elements are value initialized. Not allowed with C style arrays.</span>
<span class="hljs-keyword">decltype</span>(arr1) arr3 = arr1; <span class="hljs-comment">// OK, as types match</span>
</div></code></pre>
<h4 id="some-more-operations-on-containers">Some more operations on containers</h4>
<p>swap(c1, c2) --&gt; Swaps contents (same type of container)
c1.swap(c2)<br>
c1.assign(c2) --&gt; replace contents of c1 with those of c2<br>
c1.assign(&lt;initializer_list&gt;)<br>
c1.assign(beg_it, end_it)</p>
<p><code>assign</code> operation is <em>not</em> valid on <code>array</code> type.<br>
<code>swap</code> operation runs in const time, as underlying storage is swapped. However, this is not the case for <code>array</code>, where elements are swapped one by one.</p>
<p>containers allow the use of relational operators like <code>&lt;</code>, <code>==</code> etc. However, these are valid only if the underlying element type supports these operations.</p>
<p>most of the containers provide <code>insert</code> member function, that takes an iterator, and inserts the element <em>before</em> the iterator. This allows to insert an element at beginning as well as at end.</p>
<pre class="hljs"><code><div>svec.insert(iter, <span class="hljs-string">"abc"</span>);
svec.insert(iter, <span class="hljs-number">10</span>, <span class="hljs-string">"abc"</span>);
svec.insert(iter, slist.begin(), slist.end());
svec.insert(iter, {<span class="hljs-string">"abc"</span>, <span class="hljs-string">"def"</span>});
</div></code></pre>

</body>
</html>
